import numpy as np


# TODO: Test


def get_eulerian_transformation_matrix(g: np.ndarray[np.float64]) -> np.ndarray[np.float64]:
    big_m: np.ndarray[np.float64] = np.zeros(g.shape)

    if g.ndim == 2:
        assert np.linalg.norm(g - g.T, np.inf) < 1e-8, "Input Tensor is not symmetric"

        # Explicit Cholesky Decomposition
        f0: np.ndarray[np.float64] = g[3, 3]
        f1: np.ndarray[np.float64] = (-g[2, 3]**2 + g[2, 2] * f0)
        f2: np.ndarray[np.float64] = (2 * g[1, 2] * g[1, 3] - g[3, 3] * g[1, 2]**2 - g[2, 2] * g[1, 3]**2 + g[1, 1] * f1)
        f3: np.ndarray[np.float64] = (- 2 * g[3, 3] * g[0, 1] * g[0, 2] * g[1, 2] + 2 * g[0, 2] * g[0, 3] * g[1, 2] * g[1, 3] +
                                      2 * g[0, 1] * g[0, 2] * g[1, 3] * g[2, 3] + 2 * g[0, 1] * g[0, 3] * g[1, 2] * g[2, 3] -
                                      g[0, 1] ** 2 * g[2, 3] ** 2 - g[0, 2] ** 2 * g[1, 3] ** 2 - g[0, 3] ** 2 * g[1, 2] ** 2 +
                                      g[2, 2] * (- 2 * g[0, 1] * g[0, 3] * g[1, 3] + g[3, 3] * g[0, 1] ** 2) + g[1, 1] *
                                      (- 2 * g[0, 2] * g[0, 3] * g[2, 3] + g[3, 3] * g[0, 2] ** 2 + g[2, 2] * g[0, 3] ** 2) -
                                      g[0, 0] * f2)

        big_m[0, 0] = np.emath.sqrt(f2 / f3)
        big_m[1, 0] = (g[0, 1] * g[2, 3] ** 2 + g[0, 2] * g[1, 2] * g[3, 3] - g[0, 2] * g[1, 3] * g[2, 3] - g[0, 3] * g[1, 2] *
                       g[2, 3] + g[0, 3] * g[1, 3] * g[2, 2] - g[0, 1] * g[2, 2] * g[3, 3]) / np.emath.sqrt(f2 * f3)
        big_m[2, 0] = (g[0, 2] * g[1, 3] ** 2 - g[0, 3] * g[1, 2] * g[1, 3] + g[0, 1] * g[1, 2] * g[3, 3] - g[0, 1] * g[1, 3] *
                       g[2, 3] - g[0, 2] * g[1, 1] * g[3, 3] + g[0, 3] * g[1, 1] * g[2, 3]) / np.emath.sqrt(f2 * f3)
        big_m[3, 0] = (g[0, 3] * g[1, 2] ** 2 - g[0, 2] * g[1, 2] * g[1, 3] - g[0, 1] * g[1, 2] * g[2, 3] + g[0, 1] * g[1, 3] *
                       g[2, 2] + g[0, 2] * g[1, 1] * g[2, 3] - g[0, 3] * g[1, 1] * g[2, 2]) / np.emath.sqrt(f2 * f3)

        big_m[1, 1] = np.emath.sqrt(f1 / f2)
        big_m[2, 1] = (g[1, 3] * g[2, 3] - g[1, 2] * g[3, 3]) / np.emath.sqrt(f1 * f2)
        big_m[3, 1] = (g[1, 2] * g[2, 3] - g[1, 3] * g[2, 2]) / np.emath.sqrt(f1 * f2)

        big_m[2, 2] = np.emath.sqrt(f0 / f1)
        big_m[3, 2] = -g[2, 3] / np.emath.sqrt(f0 * f1)

        big_m[3, 3] = np.emath.sqrt(1 / f0)

    elif g.ndim == 6:
        # Explicit Cholesky Decomposition
        f0 = g[:, :, :, :, 4, 4]
        f1 = (- g[:, :, :, :, 3, 4]**2 + g[:, :, :, :, 3, 3] * f0)
        f2 = (2 * g[:, :, :, :, 2, 3] * g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 4] - g[:, :, :, :, 4, 4] * g[:, :, :, :, 2, 3]**2 -
              g[:, :, :, :, 3, 3] * g[:, :, :, :, 2, 4]**2 + g[:, :, :, :, 2, 2] * f1)
        f3 = (- 2 * g[:, :, :, :, 4, 4] * g[:, :, :, :, 1, 2] * g[:, :, :, :, 1, 3] * g[:, :, :, :, 2, 3] + 2 *
              g[:, :, :, :, 1, 3] * g[:, :, :, :, 1, 4] * g[:, :, :, :, 2, 3] * g[:, :, :, :, 2, 4] + 2 * g[:, :, :, :, 1, 2] *
              g[:, :, :, :, 1, 3] * g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 4] + 2 * g[:, :, :, :, 1, 2] * g[:, :, :, :, 1, 4] *
              g[:, :, :, :, 2, 3] * g[:, :, :, :, 3, 4] - g[:, :, :, :, 1, 2]**2 * g[:, :, :, :, 3, 4]**2 -
              g[:, :, :, :, 1, 3]**2 * g[:, :, :, :, 2, 4]**2 - g[:, :, :, :, 1, 4]**2 * g[:, :, :, :, 2, 3]**2 +
              g[:, :, :, :, 3, 3] * (- 2 * g[:, :, :, :, 1, 2] * g[:, :, :, :, 1, 4] * g[:, :, :, :, 2, 4] +
                                     g[:, :, :, :, 4, 4] * g[:, :, :, :, 1, 2]**2) + g[:, :, :, :, 2, 2] *
              (- 2 * g[:, :, :, :, 1, 3] * g[:, :, :, :, 1, 4] * g[:, :, :, :, 3, 4] + g[:, :, :, :, 4, 4] *
               g[:, :, :, :, 1, 3]**2 + g[:, :, :, :, 3, 3] * g[:, :, :, :, 1, 4]**2) - g[:, :, :, :, 1, 1] * f2)

        big_m[:, :, :, :, 1, 1] =  np.emath.sqrt(f2 / f3)
        big_m[:, :, :, :, 2, 1] =  (g[:, :, :, :, 1, 2] * g[:, :, :, :, 3, 4]**2 + g[:, :, :, :, 1, 3] * g[:, :, :, :, 2, 3] *
                                    g[:, :, :, :, 4, 4] - g[:, :, :, :, 1, 3] * g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 4] -
                                    g[:, :, :, :, 1, 4] * g[:, :, :, :, 2, 3] * g[:, :, :, :, 3, 4] + g[:, :, :, :, 1, 4] *
                                    g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 3] - g[:, :, :, :, 1, 2] * g[:, :, :, :, 3, 3] *
                                    g[:, :, :, :, 4, 4]) / np.emath.sqrt(f2 * f3)
        big_m[:, :, :, :, 3, 1] =  (g[:, :, :, :, 1, 3] * g[:, :, :, :, 2, 4]**2 - g[:, :, :, :, 1, 4] * g[:, :, :, :, 2, 3] *
                                    g[:, :, :, :, 2, 4] + g[:, :, :, :, 1, 2] * g[:, :, :, :, 2, 3] * g[:, :, :, :, 4, 4] -
                                    g[:, :, :, :, 1, 2] * g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 4] - g[:, :, :, :, 1, 3] *
                                    g[:, :, :, :, 2, 2] * g[:, :, :, :, 4, 4] + g[:, :, :, :, 1, 4] * g[:, :, :, :, 2, 2] *
                                    g[:, :, :, :, 3, 4]) / np.emath.sqrt(f2 * f3)
        big_m[:, :, :, :, 4, 1] =  (g[:, :, :, :, 1, 4] * g[:, :, :, :, 2, 3]**2 - g[:, :, :, :, 1, 3] * g[:, :, :, :, 2, 3] *
                                    g[:, :, :, :, 2, 4] - g[:, :, :, :, 1, 2] * g[:, :, :, :, 2, 3] * g[:, :, :, :, 3, 4] +
                                    g[:, :, :, :, 1, 2] * g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 3] + g[:, :, :, :, 1, 3] *
                                    g[:, :, :, :, 2, 2] * g[:, :, :, :, 3, 4] - g[:, :, :, :, 1, 4] * g[:, :, :, :, 2, 2] *
                                    g[:, :, :, :, 3, 3]) / np.emath.sqrt(f2 * f3)

        big_m[:, :, :, :, 2, 2] =  np.emath.sqrt(f1 / f2)
        big_m[:, :, :, :, 3, 2] =  ((g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 4] - g[:, :, :, :, 2, 3] * g[:, :, :, :, 4, 4]) /
                                    np.emath.sqrt(f1 * f2))
        big_m[:, :, :, :, 4, 2] =  ((g[:, :, :, :, 2, 3] * g[:, :, :, :, 3, 4] - g[:, :, :, :, 2, 4] * g[:, :, :, :, 3, 3]) /
                                    np.emath.sqrt(f1 * f2))

        big_m[:, :, :, :, 3, 3] =  np.emath.sqrt(f0 / f1)
        big_m[:, :, :, :, 4, 3] =  -g[:, :, :, :, 3, 4] / np.emath.sqrt(f0 * f1)

        big_m[:, :, :, :, 4, 4] =  np.emath.sqrt(1 / f0)
    else:
        raise AssertionError("Unrecognized tensor size")

    if not np.isfinite(big_m.max()) or not np.isfinite(big_m.min()):
        raise AssertionError("Eulerian Transformation is Infinite - Numerical Precision Insufficient")

    if np.iscomplexobj(big_m):
        raise AssertionError("Eulerian Transformation is imaginary - Numerical Precision Insufficient")

    return big_m
